theory Contract begin

// Function signature and definition of the equational theory E

functions: check_getmsg/2, check_rep/2, checkpcs/5, convertpcs/2,
           fakepcs/4, fst/1, get_rep/1, pair/2, pcs/3, pk/1, rep/2 [private],
           sign/2, snd/1, true/0, verify/3
equations:
    check_getmsg(sign(xm, xsk), pk(xsk)) = xm,
    check_rep(rep(m, loc), loc) = m,
    checkpcs(xc, xpk, pk(ysk), zpk, fakepcs(xpk, ysk, zpk, xc)) = true,
    checkpcs(xc, pk(xsk), ypk, zpk, pcs(sign(xc, xsk), ypk, zpk)) = true,
    convertpcs(zsk, pcs(sign(xc, xsk), ypk, pk(zsk))) = sign(xc, xsk),
    fst(<x.1, x.2>) = x.1,
    get_rep(rep(m, loc)) = m,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true

section{* GM Protocol for Contract signing *}

rule (modulo E) Init_:
   [ ] --[ Init( ) ]-> [ State_( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_0_:
   [ State_( ) ] --> [ !Semistate_1( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_1_:
   [ !Semistate_1( ) ] --> [ State_1( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_skT_1:
   [ State_1( ), Fr( skT ) ] --> [ State_11( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_TrustedPartyskT_11:
   [ State_11( skT ) ]
  --[ Event( ), TrustedParty( skT ) ]->
   [ State_111( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) out_pkskT_111:
   [ State_111( skT ) ] --> [ State_1111( skT ), Out( pk(skT) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par_1111:
   [ State_1111( skT ) ] --> [ State_11111( skT ), State_11112( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par_11111:
   [ State_11111( skT ) ] --> [ State_111111( skT ), State_111112( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par_111111:
   [ State_111111( skT ) ]
  -->
   [ State_1111111( skT ), State_1111112( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par_1111111:
   [ State_1111111( skT ) ]
  -->
   [ State_11111111( skT ), State_11111112( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par_11111111:
   [ State_11111111( skT ) ]
  -->
   [ State_111111111( skT ), State_111111112( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_0_111111111:
   [ State_111111111( skT ) ] --> [ !Semistate_1111111111( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_1_111111111:
   [ !Semistate_1111111111( skT ) ] --> [ State_1111111111( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) in_abort_ct_pk1_pk2_ysig__1111111111:
   [ State_1111111111( skT ), In( <'abort', ct, pk1, pk2, ysig> ) ]
  -->
   [ State_11111111111( ct, pk1, pk2, skT, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) if_eqcheck_getmsgysig_pk1_ct_pk1_pk2__0_11111111111:
   [ State_11111111111( ct, pk1, pk2, skT, ysig ) ]
  --[ Pred_eq( check_getmsg(ysig, pk1), <ct, pk1, pk2> ) ]->
   [ State_111111111111( ct, pk1, pk2, skT, ysig ) ]

  /*
  rule (modulo AC) if_eqcheck_getmsgysig_pk1_ct_pk1_pk2__0_11111111111:
     [ State_11111111111( ct, pk1, pk2, skT, ysig ) ]
    --[ Pred_eq( z, <ct, pk1, pk2> ) ]->
     [ State_111111111111( ct, pk1, pk2, skT, ysig ) ]
    variants (modulo AC)
    1. pk1   = pk1.7
       ysig  = ysig.7
       z     = check_getmsg(ysig.7, pk1.7)
    
    2. pk1   = pk(x.7)
       ysig  = sign(x.8, x.7)
       z     = x.8
  */

rule (modulo E) if_eqcheck_getmsgysig_pk1_ct_pk1_pk2__1_11111111111:
   [ State_11111111111( ct, pk1, pk2, skT, ysig ) ]
  --[ Pred_not_eq( check_getmsg(ysig, pk1), <ct, pk1, pk2> ) ]->
   [ State_111111111112( ct, pk1, pk2, skT, ysig ) ]

  /*
  rule (modulo AC) if_eqcheck_getmsgysig_pk1_ct_pk1_pk2__1_11111111111:
     [ State_11111111111( ct, pk1, pk2, skT, ysig ) ]
    --[ Pred_not_eq( z, <ct, pk1, pk2> ) ]->
     [ State_111111111112( ct, pk1, pk2, skT, ysig ) ]
    variants (modulo AC)
    1. pk1   = pk1.7
       ysig  = ysig.7
       z     = check_getmsg(ysig.7, pk1.7)
    
    2. pk1   = pk(x.7)
       ysig  = sign(x.8, x.7)
       z     = x.8
  */

rule (modulo E) lock_ct_111111111111:
   [ State_111111111111( ct, pk1, pk2, skT, ysig ), Fr( ~lock7 ) ]
  --[ Lock( ~lock7, ct ) ]->
   [ State_1111111111111( ~lock7, ct, pk1, pk2, skT, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_ct_as_state_0_1111111111111:
   [ State_1111111111111( ~lock7, ct, pk1, pk2, skT, ysig ) ]
  --[ IsIn( ct, state ) ]->
   [ State_11111111111111( ~lock7, ct, pk1, pk2, skT, state, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_ct_as_state_1_1111111111111:
   [ State_1111111111111( ~lock7, ct, pk1, pk2, skT, ysig ) ]
  --[ IsNotSet( ct ) ]->
   [ State_11111111111112( ~lock7, ct, pk1, pk2, skT, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlock_ct_11111111111111:
   [ State_11111111111111( ~lock7, ct, pk1, pk2, skT, state, ysig ) ]
  --[ Unlock( ~lock7, ct ) ]->
   [ State_111111111111111( ~lock7, ct, pk1, pk2, skT, state, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_111111111111111:
   [ State_111111111111111( ~lock7, ct, pk1, pk2, skT, state, ysig ) ]
  -->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) insert_ct_aborted__11111111111112:
   [ State_11111111111112( ~lock7, ct, pk1, pk2, skT, ysig ) ]
  --[ Insert( ct, 'aborted' ) ]->
   [ State_111111111111121( ~lock7, ct, pk1, pk2, skT, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Abort1ct_111111111111121:
   [ State_111111111111121( ~lock7, ct, pk1, pk2, skT, ysig ) ]
  --[ Event( ), Abort1( ct ) ]->
   [ State_1111111111111211( ~lock7, ct, pk1, pk2, skT, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlock_ct_1111111111111211:
   [ State_1111111111111211( ~lock7, ct, pk1, pk2, skT, ysig ) ]
  --[ Unlock( ~lock7, ct ) ]->
   [ State_11111111111112111( ~lock7, ct, pk1, pk2, skT, ysig ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) out_sign_ct_pk1_pk2_ysig_skT_11111111111112111:
   [ State_11111111111112111( ~lock7, ct, pk1, pk2, skT, ysig ) ]
  -->
   [
   State_111111111111121111( ~lock7, ct, pk1, pk2, skT, ysig ),
   Out( sign(<<ct, pk1, pk2>, ysig>, skT) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_111111111111121111:
   [ State_111111111111121111( ~lock7, ct, pk1, pk2, skT, ysig ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_111111111112:
   [ State_111111111112( ct, pk1, pk2, skT, ysig ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_0_111111112:
   [ State_111111112( skT ) ] --> [ !Semistate_1111111121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_1_111111112:
   [ !Semistate_1111111121( skT ) ] --> [ State_1111111121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) in_resolve2_ct_pk1_pk2_ypcs1_ysig2__1111111121:
   [ State_1111111121( skT ), In( <'resolve2', ct, pk1, pk2, ypcs1, ysig2> )
   ]
  -->
   [ State_11111111211( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) if_eqcheck_getmsgysig2_pk2_ct_0_11111111211:
   [ State_11111111211( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Pred_eq( check_getmsg(ysig2, pk2), ct ) ]->
   [ State_111111112111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /*
  rule (modulo AC) if_eqcheck_getmsgysig2_pk2_ct_0_11111111211:
     [ State_11111111211( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    --[ Pred_eq( z, ct ) ]->
     [ State_111111112111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    variants (modulo AC)
    1. pk2   = pk2.8
       ysig2 = ysig2.8
       z     = check_getmsg(ysig2.8, pk2.8)
    
    2. pk2   = pk(x.8)
       ysig2 = sign(x.9, x.8)
       z     = x.9
  */

rule (modulo E) if_eqcheck_getmsgysig2_pk2_ct_1_11111111211:
   [ State_11111111211( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Pred_not_eq( check_getmsg(ysig2, pk2), ct ) ]->
   [ State_111111112112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /*
  rule (modulo AC) if_eqcheck_getmsgysig2_pk2_ct_1_11111111211:
     [ State_11111111211( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    --[ Pred_not_eq( z, ct ) ]->
     [ State_111111112112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    variants (modulo AC)
    1. pk2   = pk2.8
       ysig2 = ysig2.8
       z     = check_getmsg(ysig2.8, pk2.8)
    
    2. pk2   = pk(x.8)
       ysig2 = sign(x.9, x.8)
       z     = x.9
  */

rule (modulo E) if_eqcheck_getmsgconvertpcsskT_ypcs1_pk1_ct_0_111111112111:
   [ State_111111112111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Pred_eq( check_getmsg(convertpcs(skT, ypcs1), pk1), ct ) ]->
   [ State_1111111121111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /*
  rule (modulo AC) if_eqcheck_getmsgconvertpcsskT_ypcs1_pk1_ct_0_111111112111:
     [ State_111111112111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    --[ Pred_eq( z, ct ) ]->
     [ State_1111111121111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    variants (modulo AC)
    1. pk1   = pk1.8
       skT   = skT.8
       ypcs1 = ypcs1.8
       z     = check_getmsg(convertpcs(skT.8, ypcs1.8), pk1.8)
    
    2. pk1   = pk1.12
       skT   = x.8
       ypcs1 = pcs(sign(x.9, x.11), x.10, pk(x.8))
       z     = check_getmsg(sign(x.9, x.11), pk1.12)
    
    3. pk1   = pk(x.8)
       skT   = x.9
       ypcs1 = pcs(sign(x.10, x.8), x.11, pk(x.9))
       z     = x.10
  */

rule (modulo E) if_eqcheck_getmsgconvertpcsskT_ypcs1_pk1_ct_1_111111112111:
   [ State_111111112111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Pred_not_eq( check_getmsg(convertpcs(skT, ypcs1), pk1), ct ) ]->
   [ State_1111111121112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /*
  rule (modulo AC) if_eqcheck_getmsgconvertpcsskT_ypcs1_pk1_ct_1_111111112111:
     [ State_111111112111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    --[ Pred_not_eq( z, ct ) ]->
     [ State_1111111121112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    variants (modulo AC)
    1. pk1   = pk1.8
       skT   = skT.8
       ypcs1 = ypcs1.8
       z     = check_getmsg(convertpcs(skT.8, ypcs1.8), pk1.8)
    
    2. pk1   = pk1.12
       skT   = x.8
       ypcs1 = pcs(sign(x.9, x.11), x.10, pk(x.8))
       z     = check_getmsg(sign(x.9, x.11), pk1.12)
    
    3. pk1   = pk(x.8)
       skT   = x.9
       ypcs1 = pcs(sign(x.10, x.8), x.11, pk(x.9))
       z     = x.10
  */

rule (modulo E) if_eqcheckpcsct_pk1_pk2_pkskT_ypcs1_true_0_1111111121111:
   [ State_1111111121111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Pred_eq( checkpcs(ct, pk1, pk2, pk(skT), ypcs1), true ) ]->
   [ State_11111111211111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /*
  rule (modulo AC) if_eqcheckpcsct_pk1_pk2_pkskT_ypcs1_true_0_1111111121111:
     [ State_1111111121111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    --[ Pred_eq( z, true ) ]->
     [ State_11111111211111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    variants (modulo AC)
    1. ct    = ct.8
       pk1   = pk1.8
       pk2   = pk2.8
       skT   = skT.8
       ypcs1 = ypcs1.8
       z     = checkpcs(ct.8, pk1.8, pk2.8, pk(skT.8), ypcs1.8)
    
    2. ct    = x.8
       pk1   = x.9
       pk2   = pk(x.10)
       skT   = x.11
       ypcs1 = fakepcs(x.9, x.10, pk(x.11), x.8)
       z     = true
    
    3. ct    = x.8
       pk1   = pk(x.9)
       pk2   = x.11
       skT   = x.10
       ypcs1 = pcs(sign(x.8, x.9), x.11, pk(x.10))
       z     = true
  */

rule (modulo E) if_eqcheckpcsct_pk1_pk2_pkskT_ypcs1_true_1_1111111121111:
   [ State_1111111121111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Pred_not_eq( checkpcs(ct, pk1, pk2, pk(skT), ypcs1), true ) ]->
   [ State_11111111211112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /*
  rule (modulo AC) if_eqcheckpcsct_pk1_pk2_pkskT_ypcs1_true_1_1111111121111:
     [ State_1111111121111( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    --[ Pred_not_eq( z, true ) ]->
     [ State_11111111211112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    variants (modulo AC)
    1. ct    = ct.8
       pk1   = pk1.8
       pk2   = pk2.8
       skT   = skT.8
       ypcs1 = ypcs1.8
       z     = checkpcs(ct.8, pk1.8, pk2.8, pk(skT.8), ypcs1.8)
    
    2. ct    = x.8
       pk1   = x.9
       pk2   = pk(x.10)
       skT   = x.11
       ypcs1 = fakepcs(x.9, x.10, pk(x.11), x.8)
       z     = true
    
    3. ct    = x.8
       pk1   = pk(x.9)
       pk2   = x.11
       skT   = x.10
       ypcs1 = pcs(sign(x.8, x.9), x.11, pk(x.10))
       z     = true
  */

rule (modulo E) lock_ct_11111111211111:
   [ State_11111111211111( ct, pk1, pk2, skT, ypcs1, ysig2 ), Fr( ~lock7 ) ]
  --[ Lock( ~lock7, ct ) ]->
   [ State_111111112111111( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_ct_as_status_0_111111112111111:
   [ State_111111112111111( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ IsIn( ct, status ) ]->
   [
   State_1111111121111111( ~lock7, ct, pk1, pk2, skT, status, ypcs1, ysig2 )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_ct_as_status_1_111111112111111:
   [ State_111111112111111( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ IsNotSet( ct ) ]->
   [ State_1111111121111112( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlock_ct_1111111121111111:
   [
   State_1111111121111111( ~lock7, ct, pk1, pk2, skT, status, ypcs1, ysig2 )
   ]
  --[ Unlock( ~lock7, ct ) ]->
   [
   State_11111111211111111( ~lock7, ct, pk1, pk2, skT, status, ypcs1, ysig2
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_11111111211111111:
   [
   State_11111111211111111( ~lock7, ct, pk1, pk2, skT, status, ypcs1, ysig2
   )
   ]
  -->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) insert_ct_resolved2__1111111121111112:
   [ State_1111111121111112( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Insert( ct, 'resolved2' ) ]->
   [ State_11111111211111121( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Resolve2ct_11111111211111121:
   [ State_11111111211111121( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Event( ), Resolve2( ct ) ]->
   [ State_111111112111111211( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlock_ct_111111112111111211:
   [ State_111111112111111211( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  --[ Unlock( ~lock7, ct ) ]->
   [ State_1111111121111112111( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) out_sign_convertpcsskT_ypcs1_ysig2_skT_1111111121111112111:
   [ State_1111111121111112111( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  -->
   [
   State_11111111211111121111( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ),
   Out( sign(<convertpcs(skT, ypcs1), ysig2>, skT) )
   ]

  /*
  rule (modulo AC) out_sign_convertpcsskT_ypcs1_ysig2_skT_1111111121111112111:
     [ State_1111111121111112111( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
    -->
     [
     State_11111111211111121111( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ),
     Out( sign(<z, ysig2>, skT) )
     ]
    variants (modulo AC)
    1. skT   = skT.9
       ypcs1 = ypcs1.9
       z     = convertpcs(skT.9, ypcs1.9)
    
    2. skT   = x.9
       ypcs1 = pcs(sign(x.10, x.12), x.11, pk(x.9))
       z     = sign(x.10, x.12)
  */

rule (modulo E) Zero_11111111211111121111:
   [ State_11111111211111121111( ~lock7, ct, pk1, pk2, skT, ypcs1, ysig2 ) ]
  -->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_11111111211112:
   [ State_11111111211112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_1111111121112:
   [ State_1111111121112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_111111112112:
   [ State_111111112112( ct, pk1, pk2, skT, ypcs1, ysig2 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_0_11111112:
   [ State_11111112( skT ) ] --> [ !Semistate_111111121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_1_11111112:
   [ !Semistate_111111121( skT ) ] --> [ State_111111121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) in_resolve1_ct_pk1_pk2_ysig1_ypcs2__111111121:
   [ State_111111121( skT ), In( <'resolve1', ct, pk1, pk2, ysig1, ypcs2> )
   ]
  -->
   [ State_1111111211( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) if_eqcheck_getmsgysig1_pk1_ct_0_1111111211:
   [ State_1111111211( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Pred_eq( check_getmsg(ysig1, pk1), ct ) ]->
   [ State_11111112111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /*
  rule (modulo AC) if_eqcheck_getmsgysig1_pk1_ct_0_1111111211:
     [ State_1111111211( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    --[ Pred_eq( z, ct ) ]->
     [ State_11111112111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    variants (modulo AC)
    1. pk1   = pk1.8
       ysig1 = ysig1.8
       z     = check_getmsg(ysig1.8, pk1.8)
    
    2. pk1   = pk(x.8)
       ysig1 = sign(x.9, x.8)
       z     = x.9
  */

rule (modulo E) if_eqcheck_getmsgysig1_pk1_ct_1_1111111211:
   [ State_1111111211( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Pred_not_eq( check_getmsg(ysig1, pk1), ct ) ]->
   [ State_11111112112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /*
  rule (modulo AC) if_eqcheck_getmsgysig1_pk1_ct_1_1111111211:
     [ State_1111111211( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    --[ Pred_not_eq( z, ct ) ]->
     [ State_11111112112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    variants (modulo AC)
    1. pk1   = pk1.8
       ysig1 = ysig1.8
       z     = check_getmsg(ysig1.8, pk1.8)
    
    2. pk1   = pk(x.8)
       ysig1 = sign(x.9, x.8)
       z     = x.9
  */

rule (modulo E) if_eqcheck_getmsgconvertpcsskT_ypcs2_pk2_ct_0_11111112111:
   [ State_11111112111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Pred_eq( check_getmsg(convertpcs(skT, ypcs2), pk2), ct ) ]->
   [ State_111111121111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /*
  rule (modulo AC) if_eqcheck_getmsgconvertpcsskT_ypcs2_pk2_ct_0_11111112111:
     [ State_11111112111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    --[ Pred_eq( z, ct ) ]->
     [ State_111111121111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    variants (modulo AC)
    1. pk2   = pk2.8
       skT   = skT.8
       ypcs2 = ypcs2.8
       z     = check_getmsg(convertpcs(skT.8, ypcs2.8), pk2.8)
    
    2. pk2   = pk2.12
       skT   = x.8
       ypcs2 = pcs(sign(x.9, x.11), x.10, pk(x.8))
       z     = check_getmsg(sign(x.9, x.11), pk2.12)
    
    3. pk2   = pk(x.8)
       skT   = x.9
       ypcs2 = pcs(sign(x.10, x.8), x.11, pk(x.9))
       z     = x.10
  */

rule (modulo E) if_eqcheck_getmsgconvertpcsskT_ypcs2_pk2_ct_1_11111112111:
   [ State_11111112111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Pred_not_eq( check_getmsg(convertpcs(skT, ypcs2), pk2), ct ) ]->
   [ State_111111121112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /*
  rule (modulo AC) if_eqcheck_getmsgconvertpcsskT_ypcs2_pk2_ct_1_11111112111:
     [ State_11111112111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    --[ Pred_not_eq( z, ct ) ]->
     [ State_111111121112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    variants (modulo AC)
    1. pk2   = pk2.8
       skT   = skT.8
       ypcs2 = ypcs2.8
       z     = check_getmsg(convertpcs(skT.8, ypcs2.8), pk2.8)
    
    2. pk2   = pk2.12
       skT   = x.8
       ypcs2 = pcs(sign(x.9, x.11), x.10, pk(x.8))
       z     = check_getmsg(sign(x.9, x.11), pk2.12)
    
    3. pk2   = pk(x.8)
       skT   = x.9
       ypcs2 = pcs(sign(x.10, x.8), x.11, pk(x.9))
       z     = x.10
  */

rule (modulo E) if_eqcheckpcsct_pk2_pk1_pkskT_ypcs2_true_0_111111121111:
   [ State_111111121111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Pred_eq( checkpcs(ct, pk2, pk1, pk(skT), ypcs2), true ) ]->
   [ State_1111111211111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /*
  rule (modulo AC) if_eqcheckpcsct_pk2_pk1_pkskT_ypcs2_true_0_111111121111:
     [ State_111111121111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    --[ Pred_eq( z, true ) ]->
     [ State_1111111211111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    variants (modulo AC)
    1. ct    = ct.8
       pk1   = pk1.8
       pk2   = pk2.8
       skT   = skT.8
       ypcs2 = ypcs2.8
       z     = checkpcs(ct.8, pk2.8, pk1.8, pk(skT.8), ypcs2.8)
    
    2. ct    = x.8
       pk1   = x.11
       pk2   = pk(x.9)
       skT   = x.10
       ypcs2 = pcs(sign(x.8, x.9), x.11, pk(x.10))
       z     = true
    
    3. ct    = x.8
       pk1   = pk(x.10)
       pk2   = x.9
       skT   = x.11
       ypcs2 = fakepcs(x.9, x.10, pk(x.11), x.8)
       z     = true
  */

rule (modulo E) if_eqcheckpcsct_pk2_pk1_pkskT_ypcs2_true_1_111111121111:
   [ State_111111121111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Pred_not_eq( checkpcs(ct, pk2, pk1, pk(skT), ypcs2), true ) ]->
   [ State_1111111211112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /*
  rule (modulo AC) if_eqcheckpcsct_pk2_pk1_pkskT_ypcs2_true_1_111111121111:
     [ State_111111121111( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    --[ Pred_not_eq( z, true ) ]->
     [ State_1111111211112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    variants (modulo AC)
    1. ct    = ct.8
       pk1   = pk1.8
       pk2   = pk2.8
       skT   = skT.8
       ypcs2 = ypcs2.8
       z     = checkpcs(ct.8, pk2.8, pk1.8, pk(skT.8), ypcs2.8)
    
    2. ct    = x.8
       pk1   = x.11
       pk2   = pk(x.9)
       skT   = x.10
       ypcs2 = pcs(sign(x.8, x.9), x.11, pk(x.10))
       z     = true
    
    3. ct    = x.8
       pk1   = pk(x.10)
       pk2   = x.9
       skT   = x.11
       ypcs2 = fakepcs(x.9, x.10, pk(x.11), x.8)
       z     = true
  */

rule (modulo E) lock_ct_1111111211111:
   [ State_1111111211111( ct, pk1, pk2, skT, ypcs2, ysig1 ), Fr( ~lock7 ) ]
  --[ Lock( ~lock7, ct ) ]->
   [ State_11111112111111( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_ct_as_status_0_11111112111111:
   [ State_11111112111111( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ IsIn( ct, status ) ]->
   [
   State_111111121111111( ~lock7, ct, pk1, pk2, skT, status, ypcs2, ysig1 )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_ct_as_status_1_11111112111111:
   [ State_11111112111111( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ IsNotSet( ct ) ]->
   [ State_111111121111112( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlock_ct_111111121111111:
   [
   State_111111121111111( ~lock7, ct, pk1, pk2, skT, status, ypcs2, ysig1 )
   ]
  --[ Unlock( ~lock7, ct ) ]->
   [
   State_1111111211111111( ~lock7, ct, pk1, pk2, skT, status, ypcs2, ysig1 )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_1111111211111111:
   [
   State_1111111211111111( ~lock7, ct, pk1, pk2, skT, status, ypcs2, ysig1 )
   ]
  -->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) insert_ct_resolved1__111111121111112:
   [ State_111111121111112( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Insert( ct, 'resolved1' ) ]->
   [ State_1111111211111121( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Resolve1ct_1111111211111121:
   [ State_1111111211111121( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Event( ), Resolve1( ct ) ]->
   [ State_11111112111111211( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlock_ct_11111112111111211:
   [ State_11111112111111211( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  --[ Unlock( ~lock7, ct ) ]->
   [ State_111111121111112111( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) out_sign_ysig1_convertpcsskT_ypcs2_skT_111111121111112111:
   [ State_111111121111112111( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  -->
   [
   State_1111111211111121111( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ),
   Out( sign(<ysig1, convertpcs(skT, ypcs2)>, skT) )
   ]

  /*
  rule (modulo AC) out_sign_ysig1_convertpcsskT_ypcs2_skT_111111121111112111:
     [ State_111111121111112111( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
    -->
     [
     State_1111111211111121111( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ),
     Out( sign(<ysig1, z>, skT) )
     ]
    variants (modulo AC)
    1. skT   = skT.9
       ypcs2 = ypcs2.9
       z     = convertpcs(skT.9, ypcs2.9)
    
    2. skT   = x.9
       ypcs2 = pcs(sign(x.10, x.12), x.11, pk(x.9))
       z     = sign(x.10, x.12)
  */

rule (modulo E) Zero_1111111211111121111:
   [ State_1111111211111121111( ~lock7, ct, pk1, pk2, skT, ypcs2, ysig1 ) ]
  -->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_1111111211112:
   [ State_1111111211112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_111111121112:
   [ State_111111121112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_11111112112:
   [ State_11111112112( ct, pk1, pk2, skT, ypcs2, ysig1 ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_0_1111112:
   [ State_1111112( skT ) ] --> [ !Semistate_11111121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_1_1111112:
   [ !Semistate_11111121( skT ) ] --> [ State_11111121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) in_signpcssignct_sk1_pkysk_pkskT_skT_11111121:
   [
   State_11111121( skT ),
   In( sign(pcs(sign(ct, sk1), pk(ysk), pk(skT)), skT) )
   ]
  -->
   [ State_111111211( ct, sk1, skT, ysk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_AbortCertct_111111211:
   [ State_111111211( ct, sk1, skT, ysk ) ]
  --[ Event( ), AbortCert( ct ) ]->
   [ State_1111112111( ct, sk1, skT, ysk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_1111112111:
   [ State_1111112111( ct, sk1, skT, ysk ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_0_111112:
   [ State_111112( skT ) ] --> [ !Semistate_1111121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_1_111112:
   [ !Semistate_1111121( skT ) ] --> [ State_1111121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) in_sign_signct_sk1_signct_sk2_skT_1111121:
   [ State_1111121( skT ), In( sign(<sign(ct, sk1), sign(ct, sk2)>, skT) ) ]
  -->
   [ State_11111211( ct, sk1, sk2, skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_ResolveCertct_11111211:
   [ State_11111211( ct, sk1, sk2, skT ) ]
  --[ Event( ), ResolveCert( ct ) ]->
   [ State_111112111( ct, sk1, sk2, skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_111112111:
   [ State_111112111( ct, sk1, sk2, skT ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_0_11112:
   [ State_11112( skT ) ] --> [ !Semistate_111121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_1_11112:
   [ !Semistate_111121( skT ) ] --> [ State_111121( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par_111121:
   [ State_111121( skT ) ]
  -->
   [ State_1111211( skT ), State_1111212( skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_skA_1111211:
   [ State_1111211( skT ), Fr( skA ) ] --> [ State_11112111( skA, skT ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) out_pkskA_11112111:
   [ State_11112111( skA, skT ) ]
  -->
   [ State_111121111( skA, skT ), Out( pk(skA) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) in_ct_xpkB__111121111:
   [ State_111121111( skA, skT ), In( <ct, xpkB> ) ]
  -->
   [ State_1111211111( ct, skA, skT, xpkB ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) out_signct_skA_1111211111:
   [ State_1111211111( ct, skA, skT, xpkB ) ]
  -->
   [ State_11112111111( ct, skA, skT, xpkB ), Out( sign(ct, skA) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) in_sigB_11112111111:
   [ State_11112111111( ct, skA, skT, xpkB ), In( sigB ) ]
  -->
   [ State_111121111111( ct, sigB, skA, skT, xpkB ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) if_eqverifysigB_ct_xpkB_true_0_111121111111:
   [ State_111121111111( ct, sigB, skA, skT, xpkB ) ]
  --[ Pred_eq( verify(sigB, ct, xpkB), true ) ]->
   [ State_1111211111111( ct, sigB, skA, skT, xpkB ) ]

  /*
  rule (modulo AC) if_eqverifysigB_ct_xpkB_true_0_111121111111:
     [ State_111121111111( ct, sigB, skA, skT, xpkB ) ]
    --[ Pred_eq( z, true ) ]->
     [ State_1111211111111( ct, sigB, skA, skT, xpkB ) ]
    variants (modulo AC)
    1. ct    = ct.7
       sigB  = sigB.7
       xpkB  = xpkB.7
       z     = verify(sigB.7, ct.7, xpkB.7)
    
    2. ct    = x.7
       sigB  = sign(x.7, x.8)
       xpkB  = pk(x.8)
       z     = true
  */

rule (modulo E) if_eqverifysigB_ct_xpkB_true_1_111121111111:
   [ State_111121111111( ct, sigB, skA, skT, xpkB ) ]
  --[ Pred_not_eq( verify(sigB, ct, xpkB), true ) ]->
   [ State_1111211111112( ct, sigB, skA, skT, xpkB ) ]

  /*
  rule (modulo AC) if_eqverifysigB_ct_xpkB_true_1_111121111111:
     [ State_111121111111( ct, sigB, skA, skT, xpkB ) ]
    --[ Pred_not_eq( z, true ) ]->
     [ State_1111211111112( ct, sigB, skA, skT, xpkB ) ]
    variants (modulo AC)
    1. ct    = ct.7
       sigB  = sigB.7
       xpkB  = xpkB.7
       z     = verify(sigB.7, ct.7, xpkB.7)
    
    2. ct    = x.7
       sigB  = sign(x.7, x.8)
       xpkB  = pk(x.8)
       z     = true
  */

rule (modulo E) event_AhasSignaturect_1111211111111:
   [ State_1111211111111( ct, sigB, skA, skT, xpkB ) ]
  --[ Event( ), AhasSignature( ct ) ]->
   [ State_11112111111111( ct, sigB, skA, skT, xpkB ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_11112111111111:
   [ State_11112111111111( ct, sigB, skA, skT, xpkB ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_1111211111112:
   [ State_1111211111112( ct, sigB, skA, skT, xpkB ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_1111212:
   [ State_1111212( skT ) ] --> [ ]

  /* has exactly the trivial AC variant */

restriction set_in:
  "∀ x y #t3.
    (IsIn( x, y ) @ #t3) ⇒
    (∃ #t2.
      (((Insert( x, y ) @ #t2) ∧ (#t2 < #t3)) ∧
       (∀ #t1. (Delete( x ) @ #t1) ⇒ ((#t1 < #t2) ∨ (#t3 < #t1)))) ∧
      (∀ #t1 yp.
        (Insert( x, yp ) @ #t1) ⇒ (((#t1 < #t2) ∨ (#t1 = #t2)) ∨ (#t3 < #t1))))"

restriction set_notin:
  "∀ x #t3.
    (IsNotSet( x ) @ #t3) ⇒
    ((∀ #t1 y. (Insert( x, y ) @ #t1) ⇒ (#t3 < #t1)) ∨
     (∃ #t1.
       ((Delete( x ) @ #t1) ∧ (#t1 < #t3)) ∧
       (∀ #t2 y. ((Insert( x, y ) @ #t2) ∧ (#t2 < #t3)) ⇒ (#t2 < #t1))))"

restriction locking:
  "∀ l x lp #t1 #t3.
    ((Lock( l, x ) @ #t1) ∧ (Lock( lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock( l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0. (Unlock( l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ lp.1 #t0.
            (Lock( lp.1, x ) @ #t0) ⇒ (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ lp.1 #t0.
           (Unlock( lp.1, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction predicate_eq:
  "∀ #i a b. (Pred_eq( a, b ) @ #i) ⇒ (a = b)"
  // safety formula

restriction predicate_not_eq:
  "∀ #i a b. (Pred_not_eq( a, b ) @ #i) ⇒ (¬(a = b))"
  // safety formula

restriction single_session:
  "∀ #i #j. ((Init( ) @ #i) ∧ (Init( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

lemma aborted_and_resolved_exclusive:
  all-traces
  "¬(∃ ct #i #j. (AbortCert( ct ) @ #i) ∧ (ResolveCert( ct ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ct #i #j. (AbortCert( ct ) @ #i) ∧ (ResolveCert( ct ) @ #j)"
*/
simplify
solve( State_111111211( ct, sk1, skT, ysk ) ▶₀ #i )
  case in_signpcssignct_sk1_pkysk_pkskT_skT_11111121
  solve( State_11111211( ct, sk1.1, sk2, skT ) ▶₀ #j )
    case in_sign_signct_sk1_signct_sk2_skT_1111121
    solve( !KU( sign(pcs(sign(ct, sk1), pk(ysk), pk(~n)), ~n) ) @ #vk )
      case c_sign
      by solve( !KU( ~n ) @ #vk.3 )
    qed
  qed
qed

lemma resolved1_contract_reachable:
  exists-trace
  "(((∃ ct #i. ResolveCert( ct ) @ #i) ∧
     (∀ ct #i. (Abort1( ct ) @ #i) ⇒ (⊥))) ∧
    (∀ ct1 ct2 #i1 #i2.
      ((Resolve1( ct1 ) @ #i1) ∧ (Resolve1( ct2 ) @ #i2)) ⇒ (#i1 = #i2))) ∧
   (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ (⊥))"
/*
guarded formula characterizing all satisfying traces:
"(∃ ct #i. (ResolveCert( ct ) @ #i)) ∧
 (∀ ct #i. (Abort1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct1 ct2 #i1 #i2.
   (Resolve1( ct1 ) @ #i1) ∧ (Resolve1( ct2 ) @ #i2) ⇒ #i1 = #i2) ∧
 (∀ ct #i. (Resolve2( ct ) @ #i) ⇒ ⊥)"
*/
simplify
solve( State_11111211( ct, sk1, sk2, skT ) ▶₀ #i )
  case in_sign_signct_sk1_signct_sk2_skT_1111121
  solve( !KU( sign(<sign(ct, sk1), sign(ct, sk2)>, ~n) ) @ #vk )
    case out_sign_ysig1_convertpcsskT_ypcs2_skT_111111121111112111
    solve( (∀ #t1 y. (Insert( ct, y ) @ #t1) ⇒ #vr.15 < #t1)  ∥
           (∃ #t1.
             (Delete( ct ) @ #t1)
            ∧
             (#t1 < #vr.15) ∧
             (∀ #t2 y. (Insert( ct, y ) @ #t2) ⇒ ((¬(#t2 < #vr.15)) ∨ (#t2 < #t1)))) )
      case case_1
      solve( !KU( pcs(sign(ct, sk2), pk(sk1), pk(~n)) ) @ #vk.11 )
        case c_pcs
        solve( !KU( sign(ct, sk1) ) @ #vk.11 )
          case c_sign
          solve( !KU( sign(ct, sk2) ) @ #vk.12 )
            case c_sign
            solve( !KU( pk(sk1) ) @ #vk.11 )
              case c_pk
              solve( !KU( pk(sk2) ) @ #vk.12 )
                case c_pk
                solve( !KU( pk(~n) ) @ #vk.13 )
                  case out_pkskT_111
                  SOLVED // trace found
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma resolved2_contract_reachable:
  exists-trace
  "(((∃ ct #i. ResolveCert( ct ) @ #i) ∧
     (∀ ct #i. (Abort1( ct ) @ #i) ⇒ (⊥))) ∧
    (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ (⊥))) ∧
   (∀ ct1 ct2 #i1 #i2.
     ((Resolve2( ct1 ) @ #i1) ∧ (Resolve2( ct2 ) @ #i2)) ⇒ (#i1 = #i2))"
/*
guarded formula characterizing all satisfying traces:
"(∃ ct #i. (ResolveCert( ct ) @ #i)) ∧
 (∀ ct #i. (Abort1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct #i. (Resolve1( ct ) @ #i) ⇒ ⊥) ∧
 (∀ ct1 ct2 #i1 #i2.
   (Resolve2( ct1 ) @ #i1) ∧ (Resolve2( ct2 ) @ #i2) ⇒ #i1 = #i2)"
*/
simplify
solve( State_11111211( ct, sk1, sk2, skT ) ▶₀ #i )
  case in_sign_signct_sk1_signct_sk2_skT_1111121
  solve( !KU( sign(<sign(ct, sk1), sign(ct, sk2)>, ~n) ) @ #vk )
    case out_sign_convertpcsskT_ypcs1_ysig2_skT_1111111121111112111
    solve( (∀ #t1 y. (Insert( ct, y ) @ #t1) ⇒ #vr.15 < #t1)  ∥
           (∃ #t1.
             (Delete( ct ) @ #t1)
            ∧
             (#t1 < #vr.15) ∧
             (∀ #t2 y. (Insert( ct, y ) @ #t2) ⇒ ((¬(#t2 < #vr.15)) ∨ (#t2 < #t1)))) )
      case case_1
      solve( !KU( pcs(sign(ct, sk1), pk(sk2), pk(~n)) ) @ #vk.10 )
        case c_pcs
        solve( !KU( sign(ct, sk2) ) @ #vk.11 )
          case c_sign
          solve( !KU( sign(ct, sk1) ) @ #vk.12 )
            case c_sign
            solve( !KU( pk(sk1) ) @ #vk.11 )
              case c_pk
              solve( !KU( pk(sk2) ) @ #vk.12 )
                case c_pk
                solve( !KU( pk(~n) ) @ #vk.13 )
                  case out_pkskT_111
                  SOLVED // trace found
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

/*
WARNING: the following wellformedness checks failed!

unbound:
  rule `lookup_ct_as_state_0_1111111111111' has unbound variables: 
    state
  
  rule `lookup_ct_as_status_0_111111112111111' has unbound variables: 
    status
  
  rule `lookup_ct_as_status_0_11111112111111' has unbound variables: 
    status

Restriction actions:
  restriction `set_in' references action 
    (ProtoFact Linear "Delete" 1,1,Linear)
  but no rule has such an action.
  
  restriction `set_notin' references action 
    (ProtoFact Linear "Delete" 1,1,Linear)
  but no rule has such an action.
*/

end
/* Output
maude tool: 'maude'
 checking version: 2.7.1. OK.
 checking installation: OK.
SAPIC tool: 'sapic'
Checking availablity ... OK.


analyzing: case-studies-sapic-regression/GJM-contract/contract.spthy

------------------------------------------------------------------------------
analyzed: case-studies-sapic-regression/GJM-contract/contract.spthy

  output:          case-studies-sapic-regression/GJM-contract/contract.spthy.tmp
  processing time: 22.323670366s
  WARNING: 5 wellformedness check failed!
           The analysis results might be wrong!
  
  aborted_and_resolved_exclusive (all-traces): verified (5 steps)
  resolved1_contract_reachable (exists-trace): verified (11 steps)
  resolved2_contract_reachable (exists-trace): verified (11 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: case-studies-sapic-regression/GJM-contract/contract.spthy

  output:          case-studies-sapic-regression/GJM-contract/contract.spthy.tmp
  processing time: 22.323670366s
  WARNING: 5 wellformedness check failed!
           The analysis results might be wrong!
  
  aborted_and_resolved_exclusive (all-traces): verified (5 steps)
  resolved1_contract_reachable (exists-trace): verified (11 steps)
  resolved2_contract_reachable (exists-trace): verified (11 steps)

==============================================================================
*/
